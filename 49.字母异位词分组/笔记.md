# 笔记

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> groups;
        
        for (string& s : strs) {
            string key = s;
            sort(key.begin(), key.end());
            groups[key].push_back(s);
        }
        
        vector<vector<string>> result;
        for (auto& pair : groups) {
            result.push_back(move(pair.second));
        }
        
        return result;
    }
};
```

## 知识点

### `vector<T>` 是什么？

- `vector` 是 C++ 标准模板库（STL）中的**动态数组容器**（定义在 `<vector>` 头文件中）。
- 它可以根据需要**自动扩容**，不像普通数组大小固定。
- `T` 是模板参数，表示 vector 中存储的元素类型。

```c++
vector<int> nums;           // 存整数的动态数组
vector<double> prices;      // 存浮点数
vector<bool> flags;         // 存布尔值
```

所以，vector<T>就是一个元素类型为T的动态数组

**`push_back`** 函数用于向 **vector** 的末尾添加一个新元素

| 操作                    | 说明                             |
| ----------------------- | -------------------------------- |
| `vec.push_back("text")` | 在末尾添加一个字符串             |
| `vec.size()`            | 返回当前有多少个字符串           |
| `vec[i]`                | 访问第 `i` 个字符串（从 0 开始） |
| `vec.empty()`           | 判断是否为空                     |
| `vec.clear()`           | 清空所有字符串                   |

以上表格对于其他类型也一样

### 哈希表

哈希表（Hash Table），也叫**散列表**，是计算机科学中一种非常重要的**数据结构**，用于实现 **“键-值”（Key-Value）映射**，支持**快速插入、查找和删除**操作。

> 哈希表就相当于键值对

哈希表的目标是：

> **在平均 O(1) 的时间内完成查找、插入、删除。**

这比数组（O(n) 查找）、链表（O(n)）、甚至平衡二叉树（O(log n)）都要快！

**基本组成：**

一个哈希表包含两个核心部分：

1. **键（Key）**

- 用于标识数据的唯一标识符。
- 比如：字符串 `"apple"`、整数 `123`、身份证号等。

2. **值（Value）**

- 与键关联的实际数据。
- 比如：`"apple"` 对应的中文是 `"苹果"`，学号 `123` 对应的学生姓名是 `"张三"`。

> ✅ 例子：
>
> - Key: `"eat"` → Value: 所有它的异位词（如 `"tea"`, `"ate"`）
> - Key: 用户ID → Value: 用户信息

**工作原理：**哈希函数 + 数组

哈希表底层通常是一个**大数组**，通过 **哈希函数（Hash Function）** 把任意类型的 key 转换成一个**数组下标（索引）**。

步骤如下：

1. **输入一个 key**（比如字符串 `"hello"`）。
2. **调用哈希函数**：`hash("hello") → 1523`（一个整数）。
3. **对数组长度取模**：`index = 1523 % table_size`（比如得到 `7`）。
4. **把 (key, value) 存到数组的第 7 个位置**。

举个生活中的例子：
想象一个图书馆：书名 = key（比如《三体》），书的内容 = value，图书馆管理员有一个神奇公式（哈希函数）：“书名每个字的拼音首字母 ASCII 码相加，再模 1000”，《三体》→ 计算得 847 → 放在 847 号书架，你要借《三体》？管理员直接带你去 847 号书架，不用一本本找！这就是哈希表的思想：通过计算直接定位，而不是遍历。
**冲突（Collision）问题：**
不同的 key 可能被哈希到同一个下标，这叫`哈希冲突`。例如：
hash("abc") % 10 = 3
hash("xyz") % 10 = 3 ← 冲突！
如何解决冲突？常见方法有两种：

1. 链地址法（Chaining）（最常用）
    每个数组位置存一个链表（或 vector）。所有哈希到同一位置的 (key, value) 都放在这个链表里。查找时：先定位到桶（bucket），再在链表里线性查找。

```
数组索引: 0    1    2    3          4 ...
               ↓
            [ ("abc", val1) ]
            [ ("xyz", val2) ]  ← 同一个链表
```

C++ 的 unordered_map 就是用这种方法实现的。

2. 开放地址法（Open Addressing）
    如果位置被占了，就按某种规则（比如线性探测：+1, +2...）找下一个空位。所有元素都存在数组中，不使用链表。

**性能分析**

| 操作 | 平均时间复杂度 | 最坏情况         |
| ---- | -------------- | ---------------- |
| 插入 | O(1)           | O(n)（大量冲突） |
| 查找 | O(1)           | O(n)             |
| 删除 | O(1)           | O(n)             |

实际中，只要哈希函数设计得好、负载因子（元素数 / 数组大小）控制得当（通常 < 0.75），几乎总是 O(1)。
**在 C++ 中的使用**
C++ 标准库提供了两种哈希表：

| 容器                        | 特点                                         |
| --------------------------- | -------------------------------------------- |
| `unordered_map<Key, Value>` | 无序哈希表（最快，推荐）                     |
| `unordered_set<Key>`        | 只存 key，不存 value（用于去重、存在性判断） |

```c++
#include <unordered_map>
#include <string>

unordered_map<string, int> age;
age["Alice"] = 25;
age["Bob"] = 30;

cout << age["Alice"]; // 输出 25，O(1) 查找！
```

> 对比：map 是基于红黑树的有序映射，O(log n)；unordered_map 是哈希表，O(1) 平均。

**哈希表的典型应用场景**

1. 分组问题
    key = 排序后的字符串，value = 原始字符串列表
2. 去重
    用 unordered_set 快速判断元素是否已存在
3. 缓存（Cache）
    key = 请求参数，value = 计算结果（如网页缓存）
4. 字典/映射
    单词 → 释义，ID → 用户信息
5. 两数之和（Two Sum）
    用哈希表记录“需要的数 → 下标”

**注意事项**

- key 必须可哈希：C++ 中基本类型（int, string）都可以，自定义类型需要提供哈希函数。
- 不要假设顺序：unordered_map 是无序的！如果需要有序，用 map。
- 避免频繁 rehash：可以预先 reserve() 空间提升性能。

**总结一句话：**
哈希表是一种通过“哈希函数”将 key 映射到数组下标，从而实现近乎常数时间查找、插入、删除的数据结构。它是现代编程中性能优化的利器。
在你写的 groupAnagrams 函数中：

### move函数

`std::move` 是 C++11 引入的一个**关键工具**，用于实现 **“移动语义（Move Semantics）”**。它的核心作用是：**将一个对象的资源“转移”出去，而不是复制**，从而大幅提升性能，尤其在处理大型对象（如 `vector`、`string`、自定义动态内存类）时。

**一句话理解 `std::move`**

> **`std::move(x)` 并不移动任何东西，它只是把 `x` 转换成一个“右值引用（rvalue reference）”，告诉编译器：“你可以安全地‘偷走’`x` 的资源，我不再需要它了。”**

**为什么需要 `std::move`？**

没有移动语义的问题（C++98/03）

```cpp
vector<string> createBigVector() {
    vector<string> v(100000, "hello");
    return v; // 返回时会深拷贝整个 vector！O(n) 时间 + 内存
}
```

即使编译器做了返回值优化（RVO），在**中间赋值或传参**时仍可能触发昂贵的拷贝：

```cpp
vector<string> a = createBigVector();
vector<string> b = a; // ← 这里会深拷贝！
```

有了移动语义（C++11+）之后

```cpp
vector<string> b = std::move(a); // ← “偷走”a 的内部指针，O(1) 完成！
// 此时 a 变为空（但仍是合法对象）
```

**`std::move` 的基本用法**

语法：

```cpp
#include <utility> // std::move 定义在此头文件（但很多编译器即使不包含也能用）

T&& move(T& obj) noexcept;
```

示例 1：移动 vector

```cpp
#include <iostream>
#include <vector>
#include <string>

int main() {
    std::vector<std::string> src = {"apple", "banana", "cherry"};
    std::vector<std:: string> dest;

    std::cout << "Before move: src.size() = " << src.size() << "\n"; // 3

    dest = std::move(src); // 移动！不是拷贝！

    std::cout << "After move: src.size() = " << src.size() << "\n";  // 0（通常为空）
    std::cout << "dest[0] = " << dest[0] << "\n";                    // "apple"
}
```

输出：

```
Before move: src.size() = 3
After move: src.size() = 0
dest[0] = apple
```

> ⚠注意：移动后 `src` 处于**有效但未指定状态（valid but unspecified state）** —— 你可以对它赋值或析构，但不能假设它还有数据。

示例 2：在函数中避免拷贝（如你看到的 `groupAnagrams`）

```cpp
std::vector<std::vector<std::string>> result;
for (auto& pair : groups) {
    result.push_back(std::move(pair.second)); // 移动 vector，而非拷贝
}
```

- 如果不用 `move`：`push_back` 会调用 **拷贝构造函数**，复制整个字符串 vector。
- 用了 `move`：调用 **移动构造函数**，只复制几个指针（如 `_start`, `_finish`），O(1) 完成。

**核心概念解析**

1. **左值（lvalue） vs 右值（rvalue）**

| 类型     | 特点                         | 例子                             |
| -------- | ---------------------------- | -------------------------------- |
| **左值** | 有名字、可取地址、生命周期长 | `int x = 5;` → `x` 是左值        |
| **右值** | 临时对象、无名字、即将销毁   | `5 + 3`、`func()` 返回的临时对象 |

2. **右值引用（Rvalue Reference）**

- 语法：`T&&`
- 只能绑定到右值（或通过 `std::move` 转换的左值）
- 允许我们“劫持”临时对象的资源

```cpp
std::vector<int> v1{1,2,3};
std::vector<int>&& rref = std::move(v1); // OK：v1 被转为右值
```

3. **移动构造函数 & 移动赋值运算符**

类需要支持移动语义，必须定义：

```cpp
class MyClass {
public:
    // 移动构造函数
    MyClass(MyClass&& other) noexcept {
        // 把 other 的资源“偷过来”
        data = other.data;
        other.data = nullptr; // 让 other 不再拥有资源
    }

    // 移动赋值运算符
    MyClass& operator=(MyClass&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
private:
    int* data;
};
```

> STL 容器（`vector`, `string`, `map` 等）都已实现移动语义！

**使用 `std::move` 的注意事项**

1. **不要对移动后的对象做任何依赖其值的操作**

```cpp
vector<int> a = {1,2,3};
vector<int> b = move(a);
cout << a[0]; // ❌ 危险！a 可能为空，行为未定义
```

正确做法：移动后只对 `a` 做赋值、析构或调用 `clear()` 等不依赖内容的操作。

2. **`std::move` 不保证移动发生**

- 如果类型没有定义移动构造函数，`std::move` 会退化为拷贝。
- 所以要确保你的类型支持移动语义（STL 容器都支持）。

3. **不要滥用 `std::move`**

- 对小对象（如 `int`, `bool`）移动和拷贝一样快，没必要用。
- 在返回局部变量时，**不要写 `return std::move(local)`**！这会阻止编译器的 RVO（返回值优化）。

错误：

```cpp
vector<int> foo() {
    vector<int> v;
    return std::move(v); // 阻止 RVO，反而变慢！
}
```

正确：

```cpp
vector<int> foo() {
    vector<int> v;
    return v; // 编译器自动优化（RVO 或移动）
}
```

**总结：何时使用 `std::move`？**

| 场景                                         | 是否使用 `move`        |
| -------------------------------------------- | ---------------------- |
| 将一个**不再需要的大型对象**传递给函数或容器 | 是                     |
| 返回局部变量                                 | 否（让编译器自动优化） |
| 赋值一个临时对象（如 `vec = getVector();`）  | 否（编译器自动移动）   |
| 显式转移资源（如实现移动构造函数）           | 是                     |

**一句话记住：**

> **`std::move` 是“资源转移许可证”——它告诉编译器：“这个对象我用完了，你可以把它内部的资源直接拿走，不用复制！”**

在 `groupAnagrams` 中：

```cpp
result.push_back(move(pair.second));
```

就是典型正确用法：`pair.second` 在循环结束后就不再使用了，所以我们可以安全地“移动”它到 `result` 中，避免一次昂贵的拷贝。

### sort函数

C++ 中的 `sort` 函数是 **标准模板库（STL）** 提供的一个非常强大且高效的排序工具，定义在头文件 `<algorithm>` 中。它能对任意支持随机访问迭代器的容器（如 `vector`、数组等）进行排序。

**一、基本用法**

最简单形式：

```cpp
#include <algorithm>
#include <vector>
using namespace std;

vector<int> nums = {3, 1, 4, 1, 5};
sort(nums.begin(), nums.end()); // 升序排序
// 结果：{1, 1, 3, 4, 5}
```

参数说明：

```cpp
sort(first, last);
```

- `first`：指向要排序范围**起始位置**的迭代器（包含）
- `last`：指向要排序范围**结束位置之后一个元素**的迭代器（不包含）

> 这个区间是 **左闭右开** 的：`[first, last)`

**二、自定义排序规则**

默认是**升序**（从小到大），但你可以通过第三个参数指定**比较函数**，实现降序、按长度排序、按某种属性排序等。

方法 1：使用 lambda 表达式（推荐，C++11+）

```cpp
// 降序排序
sort(nums.begin(), nums.end(), [](int a, int b) {
    return a > b; // 注意：返回 true 表示 a 应该排在 b 前面
});
```

方法 2：使用函数对象（functor）

```cpp
struct Greater {
    bool operator()(int a, int b) const {
        return a > b;
    }
};
sort(nums.begin(), nums.end(), Greater());
```

方法 3：使用标准库比较器

```cpp
#include <functional>
sort(nums.begin(), nums.end(), greater<int>()); // 降序
sort(nums.begin(), nums.end(), less<int>());    // 升序（默认）
```

**三、对字符串排序**

1. 对单个字符串内部字符排序（常用于 anagram 问题）：

```cpp
string s = "hello";
sort(s.begin(), s.end()); // → "ehllo"
```

2. 对字符串数组按字典序排序：

```cpp
vector<string> words = {"banana", "apple", "cherry"};
sort(words.begin(), words.end()); // → {"apple", "banana", "cherry"}
```

3. 按字符串长度排序：

```cpp
sort(words.begin(), words.end(), [](const string& a, const string& b) {
    return a.size() < b.size(); // 短的在前
});
```

**四、底层实现与性能**

- **算法**：通常采用 **内省排序（Introsort）** —— 是快速排序 + 堆排序 + 插入排序的混合体。
- **时间复杂度**：**O(n log n)** 最坏情况也有保证（不像纯快排最坏 O(n²)）。
- **空间复杂度**：O(log n)（递归栈）
- **是否稳定**？❌ **不稳定**！相等元素的相对顺序可能改变。

> ✅ 如果你需要**稳定排序**（保持相等元素原有顺序），请使用 `stable_sort()`。

**五、常见误区与注意事项**

误区 ：比较函数写错逻辑

```cpp
// 错误！会导致未定义行为
sort(v.begin(), v.end(), [](int a, int b) {
    return a >= b; // 不能有等号！
});
```

> ⚠️ 比较函数必须满足**严格弱序（strict weak ordering）**：
>
> - `comp(a, a)` 必须为 false
> - 如果 `comp(a, b)` 为 true，则 `comp(b, a)` 必须为 false
> - 传递性等

✅ 正确写法：用 `<` 或 `>`，**不要用 `<=` 或 `>=`**

误区 3：对不支持随机访问的容器使用 `sort`

```cpp
list<int> lst = {3,1,4};
sort(lst.begin(), lst.end()); // ❌ 编译错误！
```

> `list` 的迭代器是双向迭代器，不是随机访问迭代器。
> 正确做法：用 `lst.sort()` 成员函数。

六、实际应用示例（结合你的 anagram 问题）

在 `groupAnagrams` 中：

```cpp
string key = s;
sort(key.begin(), key.end()); // 将 "tea" → "aet"
```

这一步是关键：**所有字母异位词排序后得到相同的字符串**，从而可以用作哈希表的 key。

七、头文件与命名空间

- 必须包含：`#include <algorithm>`
- 位于 `std` 命名空间，所以通常写 `std::sort`，但如果用了 `using namespace std;`，可以直接写 `sort`

总结

| 特性           | 说明                                              |
| -------------- | ------------------------------------------------- |
| **功能**       | 对序列进行高效排序                                |
| **头文件**     | `<algorithm>`                                     |
| **默认顺序**   | 升序（使用 `<` 比较）                             |
| **时间复杂度** | O(n log n)                                        |
| **稳定性**     | 不稳定（用 `stable_sort` 可稳定）                 |
| **适用容器**   | `vector`, `array`, 普通数组等（需随机访问迭代器） |
| **自定义排序** | 通过 lambda、函数对象或标准比较器                 |

------

> 💡 **记住**：
> `sort(begin, end)` —— 排序 `[begin, end)` 区间；
> 想降序？加 `greater<T>()` 或写 `[](a,b){ return a > b; }`；
> 想稳定？用 `stable_sort`！

掌握 `sort` 是 C++ 编程的基本功，它简洁、高效、灵活，是你解决排序类问题的首选工具！